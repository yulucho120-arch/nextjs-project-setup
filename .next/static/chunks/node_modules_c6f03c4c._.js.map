{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/is.js"],"sourcesContent":["// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,2EAA2E;AAC3E,4EAA4E;AAC5E,iDAAiD;;;;AAEjD,MAAM,UAAU;IACd;IACA;IACA;IACA;CACD;AAED,MAAM,kBAAkB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAMM,SAAS,GAAI,KAAK;IACvB,IAAI,UAAU,MAAM;QAClB,OAAO;IACT;IACA,IAAI,UAAU,WAAW;QACvB,OAAO;IACT;IACA,IAAI,UAAU,QAAQ,UAAU,OAAO;QACrC,OAAO;IACT;IACA,MAAM,SAAS,OAAO;IACtB,IAAI,QAAQ,QAAQ,CAAC,SAAS;QAC5B,OAAO;IACT;IACA,oBAAoB,GACpB,sEAAsE;IACtE,IAAI,WAAW,YAAY;QACzB,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT;IACA,IAAI,SAAS,QAAQ;QACnB,OAAO;IACT;IACA,MAAM,aAAa,cAAc;IACjC,IAAI,YAAY;QACd,OAAO;IACT;IACA,kBAAkB,GAClB,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,SAAU,KAAK;IACtB,OAAO,SAAS,MAAM,WAAW,IAAI,MAAM,WAAW,CAAC,QAAQ,IAAI,MAAM,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM;AAC3G;AAEA;;;CAGC,GACD,SAAS,cAAe,KAAK;IAC3B,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,CAAC,GAAG,CAAC;IACvE,IAAI,gBAAgB,QAAQ,CAAC,iBAAiB;QAC5C,OAAO;IACT;IACA,kBAAkB,GAClB,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/token.js"],"sourcesContent":["class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n"],"names":[],"mappings":";;;;AAAA,MAAM;IACJ;;;;GAIC,GACD,YAAa,KAAK,EAAE,IAAI,EAAE,QAAQ,CAAE;QAClC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,YAAY,GAAG,SAAS;QAC7B,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,oBAAoB,GACpB,WAAY;QACV,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,EAAE;IAC3C;IAEA;;;GAGC,GACD,QAAS,GAAG,EAAE;QACZ,oBAAoB,GACpB,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,IAAI;IACpE;AACF;AAEA,iDAAiD;AACjD,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO,OAAO,YAAY;;AACjD,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,SAAS,GAAG,IAAI,KAAK,GAAG,aAAa;AAC1C,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,gEAAgE;AAEhE,MAAM;IACJ;;;;GAIC,GACD,YAAa,IAAI,EAAE,KAAK,EAAE,aAAa,CAAE;QACvC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,aAAa,GAAG;QACrB,iCAAiC,GACjC,IAAI,CAAC,YAAY,GAAG;QACpB,iCAAiC,GACjC,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,oBAAoB,GACpB,WAAY;QACV,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,EAAE;IAC5C;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/byte-utils.js"],"sourcesContent":["// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 482, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/bl.js"],"sourcesContent":["/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 600, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/common.js"],"sourcesContent":["const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,kBAAkB;AACxB,MAAM,kBAAkB;AAExB,MAAM,uBAAuB,EAAE;AAC/B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAE3B;;;;CAIC,GACD,SAAS,iBAAkB,IAAI,EAAE,GAAG,EAAE,IAAI;IACxC,IAAI,KAAK,MAAM,GAAG,MAAM,MAAM;QAC5B,MAAM,IAAI,MAAM,GAAG,gBAAgB,yBAAyB,CAAC;IAC/D;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/0uint.js"],"sourcesContent":["/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/1negint.js"],"sourcesContent":["/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;;;AAErB;AACA;AACA;;;;AAcO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,wIAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC7E;AASO,SAAS,eAAgB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACxD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AASO,SAAS,eAAgB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACxD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AAEA,MAAM,QAAQ,OAAO,CAAC;AACtB,MAAM,QAAQ,OAAO;AASd,SAAS,eAAgB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACxD,MAAM,MAAM,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IAC3C,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,QAAQ,CAAC,IAAI;QACnB,IAAI,SAAS,OAAO,gBAAgB,EAAE;YACpC,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,MAAM,EAAE,OAAO;QACvC;IACF;IACA,IAAI,QAAQ,WAAW,KAAK,MAAM;QAChC,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,6DAA6D,CAAC;IACnG;IACA,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,MAAM,EAAE,QAAQ,OAAO,MAAM;AACrD;AAMO,SAAS,aAAc,GAAG,EAAE,KAAK;IACtC,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAY,OAAO,WAAW,WAAY,SAAS,QAAQ,QAAU,SAAS,CAAC,IAAI;IACzF,CAAA,GAAA,wIAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE;AACrD;AAEA;;;CAGC,GACD,aAAa,WAAW,GAAG,SAAS,YAAa,KAAK;IACpD,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAY,OAAO,WAAW,WAAY,SAAS,QAAQ,QAAU,SAAS,CAAC,IAAI;IACzF,oBAAoB,GACpB,mFAAmF;IACnF,IAAI,WAAW,wIAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,wIAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,wIAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,wIAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,OAAO;AACT;AAEA;;;;CAIC,GACD,aAAa,aAAa,GAAG,SAAS,cAAe,IAAI,EAAE,IAAI;IAC7D,2EAA2E;IAC3E,OAAO,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,CAAC,IAAI,kBAAkB,GAAG;AAC3F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 893, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/2bytes.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;CAGC,GAED;;;;;;CAMC,GACD,SAAS,QAAS,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM;IACzC,CAAA,GAAA,yIAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK,SAAS;IACrC,MAAM,MAAM,CAAA,GAAA,gJAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,SAAS;IACrD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,KAAK,EAAE,KAAK,SAAS;AAC7C;AASO,SAAS,mBAAoB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC5D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AASO,SAAS,aAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AASO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AASO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AAUO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,IAAI,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,2CAA2C,CAAC;IACjF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AAEA;;;;;CAKC,GACD,SAAS,WAAY,KAAK;IACxB,IAAI,MAAM,YAAY,KAAK,WAAW;QACpC,MAAM,YAAY,GAAG,MAAM,IAAI,KAAK,wIAAA,CAAA,OAAI,CAAC,MAAM,GAAG,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,MAAM,KAAK,IAAI,MAAM,KAAK;IACzF;IACA,mBAAmB;IACnB,OAAO,MAAM,YAAY;AAC3B;AAMO,SAAS,YAAa,GAAG,EAAE,KAAK;IACrC,MAAM,QAAQ,WAAW;IACzB,CAAA,GAAA,wIAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE,MAAM,MAAM;IAC/D,IAAI,IAAI,CAAC;AACX;AAEA;;;CAGC,GACD,YAAY,WAAW,GAAG,SAAS,YAAa,KAAK;IACnD,MAAM,QAAQ,WAAW;IACzB,OAAO,wIAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,MAAM,IAAI,MAAM,MAAM;AACtE;AAEA;;;;CAIC,GACD,YAAY,aAAa,GAAG,SAAS,cAAe,IAAI,EAAE,IAAI;IAC5D,OAAO,aAAa,WAAW,OAAO,WAAW;AACnD;AAOO,SAAS,aAAc,EAAE,EAAE,EAAE;IAClC,OAAO,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,IAAI,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,IAAI;AAC9E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 983, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/3string.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;CAGC,GAED;;;;;;;CAOC,GACD,SAAS,QAAS,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO;IAClD,MAAM,YAAY,SAAS;IAC3B,CAAA,GAAA,yIAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK;IAC5B,MAAM,MAAM,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAA,GAAA,gJAAA,CAAA,WAAQ,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,YAAY;IAClF,IAAI,QAAQ,iBAAiB,KAAK,MAAM;QACtC,IAAI,SAAS,GAAG,CAAA,GAAA,gJAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM;IAClD;IACA,OAAO;AACT;AASO,SAAS,oBAAqB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO;IAC5D,OAAO,QAAQ,MAAM,KAAK,GAAG,OAAO;AACtC;AASO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACvE;AASO,SAAS,eAAgB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACxD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AASO,SAAS,eAAgB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACxD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AAUO,SAAS,eAAgB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACxD,MAAM,IAAI,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,4CAA4C,CAAC;IAClF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG,GAAG;AAClC;AAEO,MAAM,eAAe,yIAAA,CAAA,cAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1046, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/4array.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;;;;AAEA;;;CAGC,GAED;;;;;;CAMC,GACD,SAAS,QAAS,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC3C,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ;AACvC;AASO,SAAS,mBAAoB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC5D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AASO,SAAS,aAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AASO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AASO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AAUO,SAAS,cAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,IAAI,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,2CAA2C,CAAC;IACjF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AASO,SAAS,sBAAuB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC/D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,oCAAoC,CAAC;IAC1E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AAMO,SAAS,YAAa,GAAG,EAAE,KAAK;IACrC,CAAA,GAAA,wIAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,wIAAA,CAAA,OAAI,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,KAAK;AAChE;AAEA,yEAAyE;AACzE,sEAAsE;AACtE,YAAY,aAAa,GAAG,wIAAA,CAAA,aAAe,CAAC,aAAa;AAEzD;;;CAGC,GACD,YAAY,WAAW,GAAG,SAAS,YAAa,KAAK;IACnD,OAAO,wIAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1116, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/5map.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;;;;AAEA;;;CAGC,GAED;;;;;;CAMC,GACD,SAAS,QAAS,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC3C,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,GAAG,EAAE,QAAQ;AACrC;AASO,SAAS,iBAAkB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC1D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AASO,SAAS,WAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AASO,SAAS,YAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AASO,SAAS,YAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AAUO,SAAS,YAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,MAAM,IAAI,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,yCAAyC,CAAC;IAC/E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AASO,SAAS,oBAAqB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC7D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAG,yIAAA,CAAA,kBAAe,CAAC,oCAAoC,CAAC;IAC1E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AAMO,SAAS,UAAW,GAAG,EAAE,KAAK;IACnC,CAAA,GAAA,wIAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,wIAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AAEA,sEAAsE;AACtE,sEAAsE;AACtE,UAAU,aAAa,GAAG,wIAAA,CAAA,aAAe,CAAC,aAAa;AAEvD;;;CAGC,GACD,UAAU,WAAW,GAAG,SAAS,YAAa,KAAK;IACjD,OAAO,wIAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1186, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/6tag.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAcO,SAAS,iBAAkB,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ;IAC5D,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,GAAG,EAAE,OAAO;AACpC;AASO,SAAS,WAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,wIAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACrE;AASO,SAAS,YAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AASO,SAAS,YAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AASO,SAAS,YAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,IAAI,wIAAA,CAAA,QAAK,CAAC,wIAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,wIAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AAMO,SAAS,UAAW,GAAG,EAAE,KAAK;IACnC,CAAA,GAAA,wIAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,wIAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AAEA,UAAU,aAAa,GAAG,wIAAA,CAAA,aAAe,CAAC,aAAa;AAEvD;;;CAGC,GACD,UAAU,WAAW,GAAG,SAAS,YAAa,KAAK;IACjD,OAAO,wIAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1229, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/7float.js"],"sourcesContent":["// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1482, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/jump.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1754, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/encode.js"],"sourcesContent":["import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2200, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/decode.js"],"sourcesContent":["import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2396, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/cborg.js"],"sourcesContent":["import { encode } from './lib/encode.js'\nimport { decode, decodeFirst, Tokeniser, tokensToObject } from './lib/decode.js'\nimport { Token, Type } from './lib/token.js'\n\n/**\n * Export the types that were present in the original manual cborg.d.ts\n * @typedef {import('./interface').TagDecoder} TagDecoder\n * There was originally just `TypeEncoder` so don't break types by renaming or not exporting\n * @typedef {import('./interface').OptionalTypeEncoder} TypeEncoder\n * @typedef {import('./interface').DecodeOptions} DecodeOptions\n * @typedef {import('./interface').EncodeOptions} EncodeOptions\n */\n\nexport {\n  decode,\n  decodeFirst,\n  Tokeniser as Tokenizer,\n  tokensToObject,\n  encode,\n  Token,\n  Type\n}\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2421, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/json/encode.js"],"sourcesContent":["import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  // @ts-ignore TokenTypeEncoder[] requires compareTokens() on each encoder, we don't use them here\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2754, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/json/decode.js"],"sourcesContent":["import { decode as _decode, decodeFirst as _decodeFirst } from '../decode.js'\nimport { Token, Type } from '../token.js'\nimport { decodeCodePointsArray } from '../byte-utils.js'\nimport { decodeErrPrefix } from '../common.js'\n\n/**\n * @typedef {import('../../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../../interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n    /** @type {string[]} */\n    this.modeStack = ['value']\n    this.lastToken = ''\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  /**\n   * @returns {number}\n   */\n  ch () {\n    return this.data[this._pos]\n  }\n\n  /**\n   * @returns {string}\n   */\n  currentMode () {\n    return this.modeStack[this.modeStack.length - 1]\n  }\n\n  skipWhitespace () {\n    let c = this.ch()\n    // @ts-ignore\n    while (c === 32 /* ' ' */ || c === 9 /* '\\t' */ || c === 13 /* '\\r' */ || c === 10 /* '\\n' */) {\n      c = this.data[++this._pos]\n    }\n  }\n\n  /**\n   * @param {number[]} str\n   */\n  expect (str) {\n    if (this.data.length - this._pos < str.length) {\n      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`)\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this._pos++] !== str[i]) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`)\n      }\n    }\n  }\n\n  parseNumber () {\n    const startPos = this._pos\n    let negative = false\n    let float = false\n\n    /**\n     * @param {number[]} chars\n     */\n    const swallow = (chars) => {\n      while (!this.done()) {\n        const ch = this.ch()\n        if (chars.includes(ch)) {\n          this._pos++\n        } else {\n          break\n        }\n      }\n    }\n\n    // lead\n    if (this.ch() === 45) { // '-'\n      negative = true\n      this._pos++\n    }\n    if (this.ch() === 48) { // '0'\n      this._pos++\n      if (this.ch() === 46) { // '.'\n        this._pos++\n        float = true\n      } else {\n        return new Token(Type.uint, 0, this._pos - startPos)\n      }\n    }\n    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    if (negative && this._pos === startPos + 1) {\n      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n    }\n    if (!this.done() && this.ch() === 46) { // '.'\n      if (float) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n      }\n      float = true\n      this._pos++\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) { // '[eE]'\n      float = true\n      this._pos++\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) { // '+', '-'\n        this._pos++\n      }\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    // @ts-ignore\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos))\n    const num = parseFloat(numStr)\n    if (float) {\n      return new Token(Type.float, num, this._pos - startPos)\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos)\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseString () {\n    /* c8 ignore next 4 */\n    if (this.ch() !== 34) { // '\"'\n      // this would be a programming error\n      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`)\n    }\n    this._pos++\n\n    // check for simple fast-path, all printable ascii, no escapes\n    // >0x10000 elements may fail fn.apply() (http://stackoverflow.com/a/22747272/680742)\n    for (let i = this._pos, l = 0; i < this.data.length && l < 0x10000; i++, l++) {\n      const ch = this.data[i]\n      if (ch === 92 || ch < 32 || ch >= 128) { // '\\', ' ', control-chars or non-trivial\n        break\n      }\n      if (ch === 34) { // '\"'\n        // @ts-ignore\n        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i))\n        this._pos = i + 1\n        return new Token(Type.string, str, l)\n      }\n    }\n\n    const startPos = this._pos\n    const chars = []\n\n    const readu4 = () => {\n      if (this._pos + 4 >= this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`)\n      }\n      let u4 = 0\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch()\n        if (ch >= 48 && ch <= 57) { // '0' && '9'\n          ch -= 48\n        } else if (ch >= 97 && ch <= 102) { // 'a' && 'f'\n          ch = ch - 97 + 10\n        } else if (ch >= 65 && ch <= 70) { // 'A' && 'F'\n          ch = ch - 65 + 10\n        } else {\n          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`)\n        }\n        u4 = u4 * 16 + ch\n        this._pos++\n      }\n      return u4\n    }\n\n    // mostly taken from feross/buffer and adjusted to fit\n    const readUtf8Char = () => {\n      const firstByte = this.ch()\n      let codePoint = null\n      /* c8 ignore next 1 */\n      let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n      if (this._pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`)\n      }\n\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        /* c8 ignore next 6 */\n        // this case is dealt with by the caller function\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = this.data[this._pos + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          fourthByte = this.data[this._pos + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n\n      /* c8 ignore next 5 */\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd\n        bytesPerSequence = 1\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000\n        chars.push(codePoint >>> 10 & 0x3ff | 0xd800)\n        codePoint = 0xdc00 | codePoint & 0x3ff\n      }\n\n      chars.push(codePoint)\n      this._pos += bytesPerSequence\n    }\n\n    // TODO: could take the approach of a quick first scan for special chars like encoding/json/decode.go#unquoteBytes\n    // and converting all of the ascii chars from the base array in bulk\n    while (!this.done()) {\n      const ch = this.ch()\n      let ch1\n      switch (ch) {\n        case 92: // '\\'\n          this._pos++\n          if (this.done()) {\n            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`)\n          }\n          ch1 = this.ch()\n          this._pos++\n          switch (ch1) {\n            case 34: // '\"'\n            case 39: // '\\''\n            case 92: // '\\'\n            case 47: // '/'\n              chars.push(ch1)\n              break\n            case 98: // 'b'\n              chars.push(8)\n              break\n            case 116: // 't'\n              chars.push(9)\n              break\n            case 110: // 'n'\n              chars.push(10)\n              break\n            case 102: // 'f'\n              chars.push(12)\n              break\n            case 114: // 'r'\n              chars.push(13)\n              break\n            case 117: // 'u'\n              chars.push(readu4())\n              break\n            default:\n              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)\n          }\n          break\n        case 34: // '\"'\n          this._pos++\n          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos)\n        default:\n          if (ch < 32) { // ' '\n            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`)\n          } else if (ch < 0x80) {\n            chars.push(ch)\n            this._pos++\n          } else {\n            readUtf8Char()\n          }\n      }\n    }\n\n    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseValue () {\n    switch (this.ch()) {\n      case 123: // '{'\n        this.modeStack.push('obj-start')\n        this._pos++\n        return new Token(Type.map, Infinity, 1)\n      case 91: // '['\n        this.modeStack.push('array-start')\n        this._pos++\n        return new Token(Type.array, Infinity, 1)\n      case 34: { // '\"'\n        return this.parseString()\n      }\n      case 110: // 'n' / null\n        this.expect([110, 117, 108, 108]) // 'null'\n        return new Token(Type.null, null, 4)\n      case 102: // 'f' / // false\n        this.expect([102, 97, 108, 115, 101]) // 'false'\n        return new Token(Type.false, false, 5)\n      case 116: // 't' / // true\n        this.expect([116, 114, 117, 101]) // 'true'\n        return new Token(Type.true, true, 4)\n      case 45: // '-'\n      case 48: // '0'\n      case 49: // '1'\n      case 50: // '2'\n      case 51: // '3'\n      case 52: // '4'\n      case 53: // '5'\n      case 54: // '6'\n      case 55: // '7'\n      case 56: // '8'\n      case 57: // '9'\n        return this.parseNumber()\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)\n    }\n  }\n\n  /**\n   * @returns {Token}\n   */\n  next () {\n    this.skipWhitespace()\n    switch (this.currentMode()) {\n      case 'value':\n        this.modeStack.pop()\n        return this.parseValue()\n      case 'array-value': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      case 'array-start': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      // @ts-ignore\n      case 'obj-key':\n        if (this.ch() === 125) { // '}'\n          this.modeStack.pop()\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.skipWhitespace()\n      case 'obj-start': { // eslint-disable-line no-fallthrough\n        this.modeStack.pop()\n        if (this.ch() === 125) { // '}'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        const token = this.parseString()\n        this.skipWhitespace()\n        if (this.ch() !== 58) { // ':'\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('obj-value')\n        return token\n      }\n      case 'obj-value': {\n        this.modeStack.pop()\n        this.modeStack.push('obj-key')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      /* c8 ignore next 2 */\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decode(data, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decodeFirst(data, options)\n}\n\nexport { decode, decodeFirst, Tokenizer }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3247, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/cborg/lib/json/json.js"],"sourcesContent":["import { encode } from './encode.js'\nimport { decode, decodeFirst, Tokenizer } from './decode.js'\n\nexport { encode, decode, decodeFirst, Tokenizer }\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3269, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/is.js"],"sourcesContent":["const typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n];\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n];\nexport function is(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (value === true || value === false) {\n    return 'boolean';\n  }\n  const typeOf = typeof value;\n  if (typeofs.includes(typeOf)) {\n    return typeOf;\n  }\n  if (typeOf === 'function') {\n    return 'Function';\n  }\n  if (Array.isArray(value)) {\n    return 'Array';\n  }\n  if (isBuffer(value)) {\n    return 'Buffer';\n  }\n  const objectType = getObjectType(value);\n  if (objectType) {\n    return objectType;\n  }\n  return 'Object';\n}\nfunction isBuffer(value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);\n}\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName;\n  }\n  return undefined;\n}"],"names":[],"mappings":";;;AAAA,MAAM,UAAU;IACd;IACA;IACA;IACA;CACD;AACD,MAAM,kBAAkB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AACM,SAAS,GAAG,KAAK;IACtB,IAAI,UAAU,MAAM;QAClB,OAAO;IACT;IACA,IAAI,UAAU,WAAW;QACvB,OAAO;IACT;IACA,IAAI,UAAU,QAAQ,UAAU,OAAO;QACrC,OAAO;IACT;IACA,MAAM,SAAS,OAAO;IACtB,IAAI,QAAQ,QAAQ,CAAC,SAAS;QAC5B,OAAO;IACT;IACA,IAAI,WAAW,YAAY;QACzB,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT;IACA,IAAI,SAAS,QAAQ;QACnB,OAAO;IACT;IACA,MAAM,aAAa,cAAc;IACjC,IAAI,YAAY;QACd,OAAO;IACT;IACA,OAAO;AACT;AACA,SAAS,SAAS,KAAK;IACrB,OAAO,SAAS,MAAM,WAAW,IAAI,MAAM,WAAW,CAAC,QAAQ,IAAI,MAAM,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM;AAC3G;AACA,SAAS,cAAc,KAAK;IAC1B,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,CAAC,GAAG,CAAC;IACvE,IAAI,gBAAgB,QAAQ,CAAC,iBAAiB;QAC5C,OAAO;IACT;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3359, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/token.js"],"sourcesContent":["class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};"],"names":[],"mappings":";;;;AAAA,MAAM;IACJ,YAAY,KAAK,EAAE,IAAI,EAAE,QAAQ,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,YAAY,GAAG,SAAS;QAC7B,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA,WAAW;QACT,OAAO,CAAC,KAAK,EAAG,IAAI,CAAC,KAAK,CAAE,EAAE,EAAG,IAAI,CAAC,IAAI,EAAG;IAC/C;IACA,QAAQ,GAAG,EAAE;QACX,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,IAAI;IACpE;AACF;AACA,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,SAAS,GAAG,IAAI,KAAK,GAAG,aAAa;AAC1C,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,MAAM;IACJ,YAAY,IAAI,EAAE,KAAK,EAAE,aAAa,CAAE;QACtC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,SAAS,GAAG;IACnB;IACA,WAAW;QACT,OAAO,CAAC,MAAM,EAAG,IAAI,CAAC,IAAI,CAAE,EAAE,EAAG,IAAI,CAAC,KAAK,EAAG;IAChD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3409, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/byte-utils.js"],"sourcesContent":["export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3649, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/bl.js"],"sourcesContent":["import {\n  alloc,\n  concat,\n  slice\n} from './byte-utils.js';\nconst defaultChunkSize = 256;\nexport class Bl {\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    this.cursor = 0;\n    this.maxCursor = -1;\n    this.chunks = [];\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      topChunk.set(bytes, chunkPos);\n    } else {\n      if (topChunk) {\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        topChunk.set(bytes, 0);\n      } else {\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}"],"names":[],"mappings":";;;AAAA;;AAKA,MAAM,mBAAmB;AAClB,MAAM;IACX,YAAY,YAAY,gBAAgB,CAAE;QACxC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,eAAe,GAAG;IACzB;IACA,QAAQ;QACN,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG,CAAC;QAClB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACtB,IAAI,CAAC,MAAM,GAAG,EAAE;QAClB;QACA,IAAI,IAAI,CAAC,eAAe,KAAK,MAAM;YACjC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;YACrC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG;QACjD;IACF;IACA,KAAK,KAAK,EAAE;QACV,IAAI,WAAW,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE;QAClD,MAAM,SAAS,IAAI,CAAC,MAAM,GAAG,MAAM,MAAM;QACzC,IAAI,UAAU,IAAI,CAAC,SAAS,GAAG,GAAG;YAChC,MAAM,WAAW,SAAS,MAAM,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,IAAI;YACpE,SAAS,GAAG,CAAC,OAAO;QACtB,OAAO;YACL,IAAI,UAAU;gBACZ,MAAM,WAAW,SAAS,MAAM,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,IAAI;gBACpE,IAAI,WAAW,SAAS,MAAM,EAAE;oBAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE,GAAG,SAAS,QAAQ,CAAC,GAAG;oBAC3D,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,GAAG;gBACjC;YACF;YACA,IAAI,MAAM,MAAM,GAAG,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE;gBACtD,WAAW,CAAA,GAAA,+KAAA,CAAA,QAAK,AAAD,EAAE,IAAI,CAAC,SAAS;gBAC/B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACjB,IAAI,CAAC,SAAS,IAAI,SAAS,MAAM;gBACjC,IAAI,IAAI,CAAC,eAAe,KAAK,MAAM;oBACjC,IAAI,CAAC,eAAe,GAAG;gBACzB;gBACA,SAAS,GAAG,CAAC,OAAO;YACtB,OAAO;gBACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACjB,IAAI,CAAC,SAAS,IAAI,MAAM,MAAM;YAChC;QACF;QACA,IAAI,CAAC,MAAM,IAAI,MAAM,MAAM;IAC7B;IACA,QAAQ,QAAQ,KAAK,EAAE;QACrB,IAAI;QACJ,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,GAAG;YAC5B,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE;YAC5B,IAAI,SAAS,IAAI,CAAC,MAAM,GAAG,MAAM,MAAM,GAAG,GAAG;gBAC3C,OAAO,IAAI,CAAC,MAAM,KAAK,MAAM,MAAM,GAAG,QAAQ,MAAM,QAAQ,CAAC,GAAG,IAAI,CAAC,MAAM;gBAC3E,IAAI,CAAC,eAAe,GAAG;gBACvB,IAAI,CAAC,MAAM,GAAG,EAAE;YAClB,OAAO;gBACL,OAAO,CAAA,GAAA,+KAAA,CAAA,QAAK,AAAD,EAAE,OAAO,GAAG,IAAI,CAAC,MAAM;YACpC;QACF,OAAO;YACL,OAAO,CAAA,GAAA,+KAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM;QACxC;QACA,IAAI,OAAO;YACT,IAAI,CAAC,KAAK;QACZ;QACA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3729, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/common.js"],"sourcesContent":["const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};"],"names":[],"mappings":";;;;;;AAAA,MAAM,kBAAkB;AACxB,MAAM,kBAAkB;AACxB,MAAM,uBAAuB,EAAE;AAC/B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,SAAS,iBAAiB,IAAI,EAAE,GAAG,EAAE,IAAI;IACvC,IAAI,KAAK,MAAM,GAAG,MAAM,MAAM;QAC5B,MAAM,IAAI,MAAM,GAAI,gBAAiB,yBAAyB,CAAC;IACjE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3755, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/0uint.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3924, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/1negint.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;\n};"],"names":[],"mappings":";;;;;;;AAAA;AAIA;AACA;;;;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,uKAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC7E;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AACA,MAAM,QAAQ,OAAO,CAAC;AACtB,MAAM,QAAQ,OAAO;AACd,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,MAAM,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IAC3C,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,QAAQ,CAAC,IAAI;QACnB,IAAI,SAAS,OAAO,gBAAgB,EAAE;YACpC,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,MAAM,EAAE,OAAO;QACvC;IACF;IACA,IAAI,QAAQ,WAAW,KAAK,MAAM;QAChC,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,6DAA6D,CAAC;IACrG;IACA,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,MAAM,EAAE,QAAQ,OAAO,MAAM;AACrD;AACO,SAAS,aAAa,GAAG,EAAE,KAAK;IACrC,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAW,OAAO,WAAW,WAAW,SAAS,QAAQ,QAAQ,SAAS,CAAC,IAAI;IACrF,CAAA,GAAA,uKAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE;AACrD;AACA,aAAa,WAAW,GAAG,SAAS,YAAY,KAAK;IACnD,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAW,OAAO,WAAW,WAAW,SAAS,QAAQ,QAAQ,SAAS,CAAC,IAAI;IACrF,IAAI,WAAW,uKAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,uKAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,uKAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,uKAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,OAAO;AACT;AACA,aAAa,aAAa,GAAG,SAAS,cAAc,IAAI,EAAE,IAAI;IAC5D,OAAO,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,CAAC,IAAI;AACtE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3992, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/2bytes.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AAIA;AACA;;;;;AAKA,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM;IACxC,CAAA,GAAA,wKAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK,SAAS;IACrC,MAAM,MAAM,CAAA,GAAA,+KAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,SAAS;IACrD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,KAAK,EAAE,KAAK,SAAS;AAC7C;AACO,SAAS,mBAAmB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,aAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,MAAM,IAAI,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,2CAA2C,CAAC;IACnF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACA,SAAS,WAAW,KAAK;IACvB,IAAI,MAAM,YAAY,KAAK,WAAW;QACpC,MAAM,YAAY,GAAG,MAAM,IAAI,KAAK,uKAAA,CAAA,OAAI,CAAC,MAAM,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAU,AAAD,EAAE,MAAM,KAAK,IAAI,MAAM,KAAK;IACzF;IACA,OAAO,MAAM,YAAY;AAC3B;AACO,SAAS,YAAY,GAAG,EAAE,KAAK;IACpC,MAAM,QAAQ,WAAW;IACzB,CAAA,GAAA,uKAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE,MAAM,MAAM;IAC/D,IAAI,IAAI,CAAC;AACX;AACA,YAAY,WAAW,GAAG,SAAS,YAAY,KAAK;IAClD,MAAM,QAAQ,WAAW;IACzB,OAAO,uKAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,MAAM,IAAI,MAAM,MAAM;AACtE;AACA,YAAY,aAAa,GAAG,SAAS,cAAc,IAAI,EAAE,IAAI;IAC3D,OAAO,aAAa,WAAW,OAAO,WAAW;AACnD;AACO,SAAS,aAAa,EAAE,EAAE,EAAE;IACjC,OAAO,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,IAAI,CAAA,GAAA,+KAAA,CAAA,UAAO,AAAD,EAAE,IAAI;AAC9E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4060, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/3string.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport { encodeBytes } from './2bytes.js';\nimport {\n  toString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length, options) {\n  const totLength = prefix + length;\n  assertEnoughData(data, pos, totLength);\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength);\n  }\n  return tok;\n}\nexport function decodeStringCompact(data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options);\n}\nexport function decodeString8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options);\n}\nexport function decodeString16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options);\n}\nexport function decodeString32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options);\n}\nexport function decodeString64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer string lengths not supported`);\n  }\n  return toToken(data, pos, 9, l, options);\n}\nexport const encodeString = encodeBytes;"],"names":[],"mappings":";;;;;;;;AAAA;AAIA;AAIA;AACA;AACA;;;;;;AAIA,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO;IACjD,MAAM,YAAY,SAAS;IAC3B,CAAA,GAAA,wKAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK;IAC5B,MAAM,MAAM,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAA,GAAA,+KAAA,CAAA,WAAQ,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,YAAY;IAClF,IAAI,QAAQ,iBAAiB,KAAK,MAAM;QACtC,IAAI,SAAS,GAAG,CAAA,GAAA,+KAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM;IAClD;IACA,OAAO;AACT;AACO,SAAS,oBAAoB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG,OAAO;AACtC;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACvE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,IAAI,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,4CAA4C,CAAC;IACpF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG,GAAG;AAClC;AACO,MAAM,eAAe,wKAAA,CAAA,cAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4113, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/4array.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AACA;;;;AACA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC1C,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ;AACvC;AACO,SAAS,mBAAmB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,aAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,MAAM,IAAI,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,2CAA2C,CAAC;IACnF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,sBAAsB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC9D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,YAAY,GAAG,EAAE,KAAK;IACpC,CAAA,GAAA,uKAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,uKAAA,CAAA,OAAI,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,KAAK;AAChE;AACA,YAAY,aAAa,GAAG,uKAAA,CAAA,aAAe,CAAC,aAAa;AACzD,YAAY,WAAW,GAAG,SAAS,YAAY,KAAK;IAClD,OAAO,uKAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4169, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/5map.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AACA;;;;AACA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC1C,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,GAAG,EAAE,QAAQ;AACrC;AACO,SAAS,iBAAiB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IACzD,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,WAAW,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACnD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,MAAM,IAAI,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,yCAAyC,CAAC;IACjF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,oBAAoB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC5D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAI,wKAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,UAAU,GAAG,EAAE,KAAK;IAClC,CAAA,GAAA,uKAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,uKAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AACA,UAAU,aAAa,GAAG,uKAAA,CAAA,aAAe,CAAC,aAAa;AACvD,UAAU,WAAW,GAAG,SAAS,YAAY,KAAK;IAChD,OAAO,uKAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4225, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/6tag.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nexport function decodeTagCompact(_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1);\n}\nexport function decodeTag8(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeTag16(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeTag32(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5);\n}\nexport function decodeTag64(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9);\n}\nexport function encodeTag(buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value);\n}\nencodeTag.compareTokens = uint.encodeUint.compareTokens;\nencodeTag.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;AAAA;AAIA;;;AACO,SAAS,iBAAiB,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,GAAG,EAAE,OAAO;AACpC;AACO,SAAS,WAAW,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACnD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,uKAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACrE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,uKAAA,CAAA,QAAK,CAAC,uKAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,uKAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,UAAU,GAAG,EAAE,KAAK;IAClC,CAAA,GAAA,uKAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,uKAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AACA,UAAU,aAAa,GAAG,uKAAA,CAAA,aAAe,CAAC,aAAa;AACvD,UAAU,WAAW,GAAG,SAAS,YAAY,KAAK;IAChD,OAAO,uKAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4265, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/7float.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${ decodeErrPrefix } undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${ decodeErrPrefix } NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${ decodeErrPrefix } Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 2139095040) >> 23;\n    const mantissa = valu32 & 8388607;\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      const logicalExponent = exponent - 127;\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 31744) {\n    return Infinity;\n  }\n  if (half === 64512) {\n    return -Infinity;\n  }\n  if (half === 32256) {\n    return NaN;\n  }\n  const exp = half >> 10 & 31;\n  const mant = half & 1023;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 32768 ? -val : val;\n}\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4466, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/jump.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4671, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/encode.js"],"sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4936, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/lib/decode.js"],"sourcesContent":["import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${ decodeErrPrefix } found repeat map key \"${ key }\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5082, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipns/node_modules/cborg/esm/cborg.js"],"sourcesContent":["import { encode } from './lib/encode.js';\nimport { decode } from './lib/decode.js';\nimport {\n  Token,\n  Type\n} from './lib/token.js';\nexport {\n  decode,\n  encode,\n  Token,\n  Type\n};"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5107, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/is.js"],"sourcesContent":["const typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n];\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n];\nexport function is(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (value === true || value === false) {\n    return 'boolean';\n  }\n  const typeOf = typeof value;\n  if (typeofs.includes(typeOf)) {\n    return typeOf;\n  }\n  if (typeOf === 'function') {\n    return 'Function';\n  }\n  if (Array.isArray(value)) {\n    return 'Array';\n  }\n  if (isBuffer(value)) {\n    return 'Buffer';\n  }\n  const objectType = getObjectType(value);\n  if (objectType) {\n    return objectType;\n  }\n  return 'Object';\n}\nfunction isBuffer(value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);\n}\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName;\n  }\n  return undefined;\n}"],"names":[],"mappings":";;;AAAA,MAAM,UAAU;IACd;IACA;IACA;IACA;CACD;AACD,MAAM,kBAAkB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AACM,SAAS,GAAG,KAAK;IACtB,IAAI,UAAU,MAAM;QAClB,OAAO;IACT;IACA,IAAI,UAAU,WAAW;QACvB,OAAO;IACT;IACA,IAAI,UAAU,QAAQ,UAAU,OAAO;QACrC,OAAO;IACT;IACA,MAAM,SAAS,OAAO;IACtB,IAAI,QAAQ,QAAQ,CAAC,SAAS;QAC5B,OAAO;IACT;IACA,IAAI,WAAW,YAAY;QACzB,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT;IACA,IAAI,SAAS,QAAQ;QACnB,OAAO;IACT;IACA,MAAM,aAAa,cAAc;IACjC,IAAI,YAAY;QACd,OAAO;IACT;IACA,OAAO;AACT;AACA,SAAS,SAAS,KAAK;IACrB,OAAO,SAAS,MAAM,WAAW,IAAI,MAAM,WAAW,CAAC,QAAQ,IAAI,MAAM,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM;AAC3G;AACA,SAAS,cAAc,KAAK;IAC1B,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,CAAC,GAAG,CAAC;IACvE,IAAI,gBAAgB,QAAQ,CAAC,iBAAiB;QAC5C,OAAO;IACT;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5197, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/token.js"],"sourcesContent":["class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};"],"names":[],"mappings":";;;;AAAA,MAAM;IACJ,YAAY,KAAK,EAAE,IAAI,EAAE,QAAQ,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,YAAY,GAAG,SAAS;QAC7B,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA,WAAW;QACT,OAAO,CAAC,KAAK,EAAG,IAAI,CAAC,KAAK,CAAE,EAAE,EAAG,IAAI,CAAC,IAAI,EAAG;IAC/C;IACA,QAAQ,GAAG,EAAE;QACX,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,IAAI;IACpE;AACF;AACA,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,SAAS,GAAG,IAAI,KAAK,GAAG,aAAa;AAC1C,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,MAAM;IACJ,YAAY,IAAI,EAAE,KAAK,EAAE,aAAa,CAAE;QACtC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,SAAS,GAAG;IACnB;IACA,WAAW;QACT,OAAO,CAAC,MAAM,EAAG,IAAI,CAAC,IAAI,CAAE,EAAE,EAAG,IAAI,CAAC,KAAK,EAAG;IAChD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5247, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/byte-utils.js"],"sourcesContent":["export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5487, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/bl.js"],"sourcesContent":["import {\n  alloc,\n  concat,\n  slice\n} from './byte-utils.js';\nconst defaultChunkSize = 256;\nexport class Bl {\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    this.cursor = 0;\n    this.maxCursor = -1;\n    this.chunks = [];\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      topChunk.set(bytes, chunkPos);\n    } else {\n      if (topChunk) {\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        topChunk.set(bytes, 0);\n      } else {\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5567, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/common.js"],"sourcesContent":["const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};"],"names":[],"mappings":";;;;;;AAAA,MAAM,kBAAkB;AACxB,MAAM,kBAAkB;AACxB,MAAM,uBAAuB,EAAE;AAC/B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,SAAS,iBAAiB,IAAI,EAAE,GAAG,EAAE,IAAI;IACvC,IAAI,KAAK,MAAM,GAAG,MAAM,MAAM;QAC5B,MAAM,IAAI,MAAM,GAAI,gBAAiB,yBAAyB,CAAC;IACjE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5593, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/0uint.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5762, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/1negint.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;\n};"],"names":[],"mappings":";;;;;;;AAAA;AAIA;AACA;;;;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,6LAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC7E;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AACA,MAAM,QAAQ,OAAO,CAAC;AACtB,MAAM,QAAQ,OAAO;AACd,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,MAAM,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IAC3C,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,QAAQ,CAAC,IAAI;QACnB,IAAI,SAAS,OAAO,gBAAgB,EAAE;YACpC,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,MAAM,EAAE,OAAO;QACvC;IACF;IACA,IAAI,QAAQ,WAAW,KAAK,MAAM;QAChC,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,6DAA6D,CAAC;IACrG;IACA,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,MAAM,EAAE,QAAQ,OAAO,MAAM;AACrD;AACO,SAAS,aAAa,GAAG,EAAE,KAAK;IACrC,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAW,OAAO,WAAW,WAAW,SAAS,QAAQ,QAAQ,SAAS,CAAC,IAAI;IACrF,CAAA,GAAA,6LAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE;AACrD;AACA,aAAa,WAAW,GAAG,SAAS,YAAY,KAAK;IACnD,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAW,OAAO,WAAW,WAAW,SAAS,QAAQ,QAAQ,SAAS,CAAC,IAAI;IACrF,IAAI,WAAW,6LAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,6LAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,6LAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,6LAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,OAAO;AACT;AACA,aAAa,aAAa,GAAG,SAAS,cAAc,IAAI,EAAE,IAAI;IAC5D,OAAO,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,CAAC,IAAI;AACtE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5830, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/2bytes.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AAIA;AACA;;;;;AAKA,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM;IACxC,CAAA,GAAA,8LAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK,SAAS;IACrC,MAAM,MAAM,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,SAAS;IACrD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,KAAK,EAAE,KAAK,SAAS;AAC7C;AACO,SAAS,mBAAmB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,aAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,MAAM,IAAI,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,2CAA2C,CAAC;IACnF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACA,SAAS,WAAW,KAAK;IACvB,IAAI,MAAM,YAAY,KAAK,WAAW;QACpC,MAAM,YAAY,GAAG,MAAM,IAAI,KAAK,6LAAA,CAAA,OAAI,CAAC,MAAM,GAAG,CAAA,GAAA,qMAAA,CAAA,aAAU,AAAD,EAAE,MAAM,KAAK,IAAI,MAAM,KAAK;IACzF;IACA,OAAO,MAAM,YAAY;AAC3B;AACO,SAAS,YAAY,GAAG,EAAE,KAAK;IACpC,MAAM,QAAQ,WAAW;IACzB,CAAA,GAAA,6LAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE,MAAM,MAAM;IAC/D,IAAI,IAAI,CAAC;AACX;AACA,YAAY,WAAW,GAAG,SAAS,YAAY,KAAK;IAClD,MAAM,QAAQ,WAAW;IACzB,OAAO,6LAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,MAAM,IAAI,MAAM,MAAM;AACtE;AACA,YAAY,aAAa,GAAG,SAAS,cAAc,IAAI,EAAE,IAAI;IAC3D,OAAO,aAAa,WAAW,OAAO,WAAW;AACnD;AACO,SAAS,aAAa,EAAE,EAAE,EAAE;IACjC,OAAO,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,IAAI,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE,IAAI;AAC9E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5898, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/3string.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport { encodeBytes } from './2bytes.js';\nimport {\n  toString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length, options) {\n  const totLength = prefix + length;\n  assertEnoughData(data, pos, totLength);\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength);\n  }\n  return tok;\n}\nexport function decodeStringCompact(data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options);\n}\nexport function decodeString8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options);\n}\nexport function decodeString16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options);\n}\nexport function decodeString32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options);\n}\nexport function decodeString64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer string lengths not supported`);\n  }\n  return toToken(data, pos, 9, l, options);\n}\nexport const encodeString = encodeBytes;"],"names":[],"mappings":";;;;;;;;AAAA;AAIA;AAIA;AACA;AACA;;;;;;AAIA,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO;IACjD,MAAM,YAAY,SAAS;IAC3B,CAAA,GAAA,8LAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK;IAC5B,MAAM,MAAM,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,YAAY;IAClF,IAAI,QAAQ,iBAAiB,KAAK,MAAM;QACtC,IAAI,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM;IAClD;IACA,OAAO;AACT;AACO,SAAS,oBAAoB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG,OAAO;AACtC;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACvE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,IAAI,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,4CAA4C,CAAC;IACpF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG,GAAG;AAClC;AACO,MAAM,eAAe,8LAAA,CAAA,cAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5951, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/4array.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AACA;;;;AACA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC1C,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ;AACvC;AACO,SAAS,mBAAmB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,aAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,MAAM,IAAI,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,2CAA2C,CAAC;IACnF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,sBAAsB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC9D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,YAAY,GAAG,EAAE,KAAK;IACpC,CAAA,GAAA,6LAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,6LAAA,CAAA,OAAI,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,KAAK;AAChE;AACA,YAAY,aAAa,GAAG,6LAAA,CAAA,aAAe,CAAC,aAAa;AACzD,YAAY,WAAW,GAAG,SAAS,YAAY,KAAK;IAClD,OAAO,6LAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6007, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/5map.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AACA;;;;AACA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC1C,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,GAAG,EAAE,QAAQ;AACrC;AACO,SAAS,iBAAiB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IACzD,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,WAAW,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACnD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,MAAM,IAAI,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,yCAAyC,CAAC;IACjF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,oBAAoB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC5D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAI,8LAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,UAAU,GAAG,EAAE,KAAK;IAClC,CAAA,GAAA,6LAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,6LAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AACA,UAAU,aAAa,GAAG,6LAAA,CAAA,aAAe,CAAC,aAAa;AACvD,UAAU,WAAW,GAAG,SAAS,YAAY,KAAK;IAChD,OAAO,6LAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6063, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/6tag.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nexport function decodeTagCompact(_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1);\n}\nexport function decodeTag8(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeTag16(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeTag32(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5);\n}\nexport function decodeTag64(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9);\n}\nexport function encodeTag(buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value);\n}\nencodeTag.compareTokens = uint.encodeUint.compareTokens;\nencodeTag.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;AAAA;AAIA;;;AACO,SAAS,iBAAiB,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,GAAG,EAAE,OAAO;AACpC;AACO,SAAS,WAAW,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACnD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,6LAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACrE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,6LAAA,CAAA,QAAK,CAAC,6LAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,6LAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,UAAU,GAAG,EAAE,KAAK;IAClC,CAAA,GAAA,6LAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,6LAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AACA,UAAU,aAAa,GAAG,6LAAA,CAAA,aAAe,CAAC,aAAa;AACvD,UAAU,WAAW,GAAG,SAAS,YAAY,KAAK;IAChD,OAAO,6LAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6103, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/7float.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${ decodeErrPrefix } undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${ decodeErrPrefix } NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${ decodeErrPrefix } Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 2139095040) >> 23;\n    const mantissa = valu32 & 8388607;\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      const logicalExponent = exponent - 127;\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 31744) {\n    return Infinity;\n  }\n  if (half === 64512) {\n    return -Infinity;\n  }\n  if (half === 32256) {\n    return NaN;\n  }\n  const exp = half >> 10 & 31;\n  const mant = half & 1023;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 32768 ? -val : val;\n}\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6304, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/jump.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6509, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/encode.js"],"sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6774, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/lib/decode.js"],"sourcesContent":["import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${ decodeErrPrefix } found repeat map key \"${ key }\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6920, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo-migrations/node_modules/cborg/esm/cborg.js"],"sourcesContent":["import { encode } from './lib/encode.js';\nimport { decode } from './lib/decode.js';\nimport {\n  Token,\n  Type\n} from './lib/token.js';\nexport {\n  decode,\n  encode,\n  Token,\n  Type\n};"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6945, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/is.js"],"sourcesContent":["const typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n];\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n];\nexport function is(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (value === true || value === false) {\n    return 'boolean';\n  }\n  const typeOf = typeof value;\n  if (typeofs.includes(typeOf)) {\n    return typeOf;\n  }\n  if (typeOf === 'function') {\n    return 'Function';\n  }\n  if (Array.isArray(value)) {\n    return 'Array';\n  }\n  if (isBuffer(value)) {\n    return 'Buffer';\n  }\n  const objectType = getObjectType(value);\n  if (objectType) {\n    return objectType;\n  }\n  return 'Object';\n}\nfunction isBuffer(value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);\n}\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName;\n  }\n  return undefined;\n}"],"names":[],"mappings":";;;AAAA,MAAM,UAAU;IACd;IACA;IACA;IACA;CACD;AACD,MAAM,kBAAkB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AACM,SAAS,GAAG,KAAK;IACtB,IAAI,UAAU,MAAM;QAClB,OAAO;IACT;IACA,IAAI,UAAU,WAAW;QACvB,OAAO;IACT;IACA,IAAI,UAAU,QAAQ,UAAU,OAAO;QACrC,OAAO;IACT;IACA,MAAM,SAAS,OAAO;IACtB,IAAI,QAAQ,QAAQ,CAAC,SAAS;QAC5B,OAAO;IACT;IACA,IAAI,WAAW,YAAY;QACzB,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT;IACA,IAAI,SAAS,QAAQ;QACnB,OAAO;IACT;IACA,MAAM,aAAa,cAAc;IACjC,IAAI,YAAY;QACd,OAAO;IACT;IACA,OAAO;AACT;AACA,SAAS,SAAS,KAAK;IACrB,OAAO,SAAS,MAAM,WAAW,IAAI,MAAM,WAAW,CAAC,QAAQ,IAAI,MAAM,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM;AAC3G;AACA,SAAS,cAAc,KAAK;IAC1B,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,CAAC,GAAG,CAAC;IACvE,IAAI,gBAAgB,QAAQ,CAAC,iBAAiB;QAC5C,OAAO;IACT;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7035, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/token.js"],"sourcesContent":["class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};"],"names":[],"mappings":";;;;AAAA,MAAM;IACJ,YAAY,KAAK,EAAE,IAAI,EAAE,QAAQ,CAAE;QACjC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,YAAY,GAAG,SAAS;QAC7B,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA,WAAW;QACT,OAAO,CAAC,KAAK,EAAG,IAAI,CAAC,KAAK,CAAE,EAAE,EAAG,IAAI,CAAC,IAAI,EAAG;IAC/C;IACA,QAAQ,GAAG,EAAE;QACX,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,IAAI;IACpE;AACF;AACA,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,MAAM,GAAG,IAAI,KAAK,GAAG,UAAU;AACpC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,OAAO;AAC9B,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,QAAQ;AAChC,KAAK,SAAS,GAAG,IAAI,KAAK,GAAG,aAAa;AAC1C,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG,SAAS;AAClC,MAAM;IACJ,YAAY,IAAI,EAAE,KAAK,EAAE,aAAa,CAAE;QACtC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,SAAS,GAAG;IACnB;IACA,WAAW;QACT,OAAO,CAAC,MAAM,EAAG,IAAI,CAAC,IAAI,CAAE,EAAE,EAAG,IAAI,CAAC,KAAK,EAAG;IAChD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7085, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/byte-utils.js"],"sourcesContent":["export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7325, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/bl.js"],"sourcesContent":["import {\n  alloc,\n  concat,\n  slice\n} from './byte-utils.js';\nconst defaultChunkSize = 256;\nexport class Bl {\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    this.cursor = 0;\n    this.maxCursor = -1;\n    this.chunks = [];\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      topChunk.set(bytes, chunkPos);\n    } else {\n      if (topChunk) {\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        topChunk.set(bytes, 0);\n      } else {\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7405, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/common.js"],"sourcesContent":["const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};"],"names":[],"mappings":";;;;;;AAAA,MAAM,kBAAkB;AACxB,MAAM,kBAAkB;AACxB,MAAM,uBAAuB,EAAE;AAC/B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,oBAAoB,CAAC,GAAG,GAAG;AAC3B,SAAS,iBAAiB,IAAI,EAAE,GAAG,EAAE,IAAI;IACvC,IAAI,KAAK,MAAM,GAAG,MAAM,MAAM;QAC5B,MAAM,IAAI,MAAM,GAAI,gBAAiB,yBAAyB,CAAC;IACjE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7431, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/0uint.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7600, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/1negint.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;\n};"],"names":[],"mappings":";;;;;;;AAAA;AAIA;AACA;;;;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,+KAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC7E;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AAC9E;AACA,MAAM,QAAQ,OAAO,CAAC;AACtB,MAAM,QAAQ,OAAO;AACd,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,MAAM,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IAC3C,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,QAAQ,CAAC,IAAI;QACnB,IAAI,SAAS,OAAO,gBAAgB,EAAE;YACpC,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,MAAM,EAAE,OAAO;QACvC;IACF;IACA,IAAI,QAAQ,WAAW,KAAK,MAAM;QAChC,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,6DAA6D,CAAC;IACrG;IACA,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,MAAM,EAAE,QAAQ,OAAO,MAAM;AACrD;AACO,SAAS,aAAa,GAAG,EAAE,KAAK;IACrC,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAW,OAAO,WAAW,WAAW,SAAS,QAAQ,QAAQ,SAAS,CAAC,IAAI;IACrF,CAAA,GAAA,+KAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE;AACrD;AACA,aAAa,WAAW,GAAG,SAAS,YAAY,KAAK;IACnD,MAAM,SAAS,MAAM,KAAK;IAC1B,MAAM,WAAW,OAAO,WAAW,WAAW,SAAS,QAAQ,QAAQ,SAAS,CAAC,IAAI;IACrF,IAAI,WAAW,+KAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,+KAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,+KAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,IAAI,WAAW,+KAAA,CAAA,iBAAmB,CAAC,EAAE,EAAE;QACrC,OAAO;IACT;IACA,OAAO;AACT;AACA,aAAa,aAAa,GAAG,SAAS,cAAc,IAAI,EAAE,IAAI;IAC5D,OAAO,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,CAAC,IAAI;AACtE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7668, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/2bytes.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AAIA;AACA;;;;;AAKA,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM;IACxC,CAAA,GAAA,gLAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK,SAAS;IACrC,MAAM,MAAM,CAAA,GAAA,uLAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,SAAS;IACrD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,KAAK,EAAE,KAAK,SAAS;AAC7C;AACO,SAAS,mBAAmB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,aAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,MAAM,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,2CAA2C,CAAC;IACnF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACA,SAAS,WAAW,KAAK;IACvB,IAAI,MAAM,YAAY,KAAK,WAAW;QACpC,MAAM,YAAY,GAAG,MAAM,IAAI,KAAK,+KAAA,CAAA,OAAI,CAAC,MAAM,GAAG,CAAA,GAAA,uLAAA,CAAA,aAAU,AAAD,EAAE,MAAM,KAAK,IAAI,MAAM,KAAK;IACzF;IACA,OAAO,MAAM,YAAY;AAC3B;AACO,SAAS,YAAY,GAAG,EAAE,KAAK;IACpC,MAAM,QAAQ,WAAW;IACzB,CAAA,GAAA,+KAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,MAAM,IAAI,CAAC,YAAY,EAAE,MAAM,MAAM;IAC/D,IAAI,IAAI,CAAC;AACX;AACA,YAAY,WAAW,GAAG,SAAS,YAAY,KAAK;IAClD,MAAM,QAAQ,WAAW;IACzB,OAAO,+KAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,MAAM,IAAI,MAAM,MAAM;AACtE;AACA,YAAY,aAAa,GAAG,SAAS,cAAc,IAAI,EAAE,IAAI;IAC3D,OAAO,aAAa,WAAW,OAAO,WAAW;AACnD;AACO,SAAS,aAAa,EAAE,EAAE,EAAE;IACjC,OAAO,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,IAAI,CAAA,GAAA,uLAAA,CAAA,UAAO,AAAD,EAAE,IAAI;AAC9E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7736, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/3string.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport { encodeBytes } from './2bytes.js';\nimport {\n  toString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length, options) {\n  const totLength = prefix + length;\n  assertEnoughData(data, pos, totLength);\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength);\n  }\n  return tok;\n}\nexport function decodeStringCompact(data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options);\n}\nexport function decodeString8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options);\n}\nexport function decodeString16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options);\n}\nexport function decodeString32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options);\n}\nexport function decodeString64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer string lengths not supported`);\n  }\n  return toToken(data, pos, 9, l, options);\n}\nexport const encodeString = encodeBytes;"],"names":[],"mappings":";;;;;;;;AAAA;AAIA;AAIA;AACA;AACA;;;;;;AAIA,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO;IACjD,MAAM,YAAY,SAAS;IAC3B,CAAA,GAAA,gLAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM,KAAK;IAC5B,MAAM,MAAM,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,MAAM,EAAE,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM,YAAY;IAClF,IAAI,QAAQ,iBAAiB,KAAK,MAAM;QACtC,IAAI,SAAS,GAAG,CAAA,GAAA,uLAAA,CAAA,QAAK,AAAD,EAAE,MAAM,MAAM,QAAQ,MAAM;IAClD;IACA,OAAO;AACT;AACO,SAAS,oBAAoB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG,OAAO;AACtC;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACvE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACxE;AACO,SAAS,eAAe,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACvD,MAAM,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,4CAA4C,CAAC;IACpF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG,GAAG;AAClC;AACO,MAAM,eAAe,gLAAA,CAAA,cAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7789, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/4array.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AACA;;;;AACA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC1C,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ;AACvC;AACO,SAAS,mBAAmB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,aAAa,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACrD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,cAAc,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACtD,MAAM,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,2CAA2C,CAAC;IACnF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,sBAAsB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC9D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,YAAY,GAAG,EAAE,KAAK;IACpC,CAAA,GAAA,+KAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,+KAAA,CAAA,OAAI,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,KAAK;AAChE;AACA,YAAY,aAAa,GAAG,+KAAA,CAAA,aAAe,CAAC,aAAa;AACzD,YAAY,WAAW,GAAG,SAAS,YAAY,KAAK;IAClD,OAAO,+KAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7845, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/5map.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;;AAAA;AAIA;AACA;;;;AACA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM;IAC1C,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE,QAAQ;AACrC;AACO,SAAS,iBAAiB,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;IACzD,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,WAAW,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACnD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG;AAC7D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,QAAQ,MAAM,KAAK,GAAG,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;AAC9D;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,MAAM,IAAI,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG;IACzC,IAAI,OAAO,MAAM,UAAU;QACzB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,yCAAyC,CAAC;IACjF;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,oBAAoB,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IAC5D,IAAI,QAAQ,eAAe,KAAK,OAAO;QACrC,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,OAAO,QAAQ,MAAM,KAAK,GAAG;AAC/B;AACO,SAAS,UAAU,GAAG,EAAE,KAAK;IAClC,CAAA,GAAA,+KAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,+KAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AACA,UAAU,aAAa,GAAG,+KAAA,CAAA,aAAe,CAAC,aAAa;AACvD,UAAU,WAAW,GAAG,SAAS,YAAY,KAAK;IAChD,OAAO,+KAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7901, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/6tag.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nexport function decodeTagCompact(_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1);\n}\nexport function decodeTag8(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeTag16(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeTag32(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5);\n}\nexport function decodeTag64(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9);\n}\nexport function encodeTag(buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value);\n}\nencodeTag.compareTokens = uint.encodeUint.compareTokens;\nencodeTag.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"],"names":[],"mappings":";;;;;;;;AAAA;AAIA;;;AACO,SAAS,iBAAiB,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ;IAC3D,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE,OAAO;AACpC;AACO,SAAS,WAAW,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACnD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,+KAAA,CAAA,YAAc,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACrE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,YAAY,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,OAAO;IACpD,OAAO,IAAI,+KAAA,CAAA,QAAK,CAAC,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE,CAAA,GAAA,+KAAA,CAAA,aAAe,AAAD,EAAE,MAAM,MAAM,GAAG,UAAU;AACtE;AACO,SAAS,UAAU,GAAG,EAAE,KAAK;IAClC,CAAA,GAAA,+KAAA,CAAA,kBAAoB,AAAD,EAAE,KAAK,+KAAA,CAAA,OAAI,CAAC,GAAG,CAAC,YAAY,EAAE,MAAM,KAAK;AAC9D;AACA,UAAU,aAAa,GAAG,+KAAA,CAAA,aAAe,CAAC,aAAa;AACvD,UAAU,WAAW,GAAG,SAAS,YAAY,KAAK;IAChD,OAAO,+KAAA,CAAA,kBAAoB,CAAC,WAAW,CAAC,MAAM,KAAK;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7941, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/7float.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${ decodeErrPrefix } undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${ decodeErrPrefix } NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${ decodeErrPrefix } Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 2139095040) >> 23;\n    const mantissa = valu32 & 8388607;\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      const logicalExponent = exponent - 127;\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 31744) {\n    return Infinity;\n  }\n  if (half === 64512) {\n    return -Infinity;\n  }\n  if (half === 32256) {\n    return NaN;\n  }\n  const exp = half >> 10 & 31;\n  const mant = half & 1023;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 32768 ? -val : val;\n}\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8142, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/jump.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8347, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/encode.js"],"sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8612, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/lib/decode.js"],"sourcesContent":["import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${ decodeErrPrefix } found repeat map key \"${ key }\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;AAIA,MAAM,uBAAuB;IAC3B,QAAQ;IACR,iBAAiB;IACjB,gBAAgB;IAChB,aAAa;AACf;AACA,MAAM;IACJ,YAAY,IAAI,EAAE,UAAU,CAAC,CAAC,CAAE;QAC9B,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,OAAO,GAAG;IACjB;IACA,OAAO;QACL,OAAO,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM;IACrC;IACA,OAAO;QACL,MAAM,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;QAC/B,IAAI,QAAQ,8KAAA,CAAA,QAAK,CAAC,IAAI;QACtB,IAAI,UAAU,WAAW;YACvB,MAAM,UAAU,8KAAA,CAAA,OAAI,CAAC,IAAI;YACzB,IAAI,CAAC,SAAS;gBACZ,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,2BAA2B,EAAG,QAAQ,EAAG,SAAS,EAAG,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,KAAM,CAAC,CAAC;YACjI;YACA,MAAM,QAAQ,MAAM;YACpB,QAAQ,QAAQ,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,OAAO,IAAI,CAAC,OAAO;QAC1D;QACA,IAAI,CAAC,GAAG,IAAI,MAAM,aAAa;QAC/B,OAAO;IACT;AACF;AACA,MAAM,OAAO,OAAO,GAAG,CAAC;AACxB,MAAM,QAAQ,OAAO,GAAG,CAAC;AACzB,SAAS,aAAa,KAAK,EAAE,SAAS,EAAE,OAAO;IAC7C,MAAM,MAAM,EAAE;IACd,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,KAAK,EAAE,IAAK;QACpC,MAAM,QAAQ,eAAe,WAAW;QACxC,IAAI,UAAU,OAAO;YACnB,IAAI,MAAM,KAAK,KAAK,UAAU;gBAC5B;YACF;YACA,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,uCAAuC,CAAC;QAC/E;QACA,IAAI,UAAU,MAAM;YAClB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,yCAAyC,EAAG,EAAG,WAAW,EAAG,MAAM,KAAK,CAAE,CAAC,CAAC;QACnH;QACA,GAAG,CAAC,EAAE,GAAG;IACX;IACA,OAAO;AACT;AACA,SAAS,WAAW,KAAK,EAAE,SAAS,EAAE,OAAO;IAC3C,MAAM,UAAU,QAAQ,OAAO,KAAK;IACpC,MAAM,MAAM,UAAU,YAAY,CAAC;IACnC,MAAM,IAAI,UAAU,IAAI,QAAQ;IAChC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,KAAK,EAAE,IAAK;QACpC,MAAM,MAAM,eAAe,WAAW;QACtC,IAAI,QAAQ,OAAO;YACjB,IAAI,MAAM,KAAK,KAAK,UAAU;gBAC5B;YACF;YACA,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,qCAAqC,CAAC;QAC7E;QACA,IAAI,QAAQ,MAAM;YAChB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,uCAAuC,EAAG,EAAG,oBAAoB,EAAG,MAAM,KAAK,CAAE,CAAC,CAAC;QAC1H;QACA,IAAI,YAAY,QAAQ,OAAO,QAAQ,UAAU;YAC/C,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,oCAAoC,EAAG,OAAO,IAAK,CAAC,CAAC;QAC5F;QACA,IAAI,QAAQ,sBAAsB,KAAK,MAAM;YAC3C,IAAI,WAAW,EAAE,GAAG,CAAC,QAAQ,CAAC,WAAW,OAAO,KAAK;gBACnD,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,uBAAuB,EAAG,IAAK,CAAC,CAAC;YACxE;QACF;QACA,MAAM,QAAQ,eAAe,WAAW;QACxC,IAAI,UAAU,MAAM;YAClB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,uCAAuC,EAAG,EAAG,sBAAsB,EAAG,MAAM,KAAK,CAAE,CAAC,CAAC;QAC5H;QACA,IAAI,SAAS;YACX,EAAE,GAAG,CAAC,KAAK;QACb,OAAO;YACL,GAAG,CAAC,IAAI,GAAG;QACb;IACF;IACA,OAAO,UAAU,IAAI;AACvB;AACA,SAAS,eAAe,SAAS,EAAE,OAAO;IACxC,IAAI,UAAU,IAAI,IAAI;QACpB,OAAO;IACT;IACA,MAAM,QAAQ,UAAU,IAAI;IAC5B,IAAI,MAAM,IAAI,KAAK,+KAAA,CAAA,OAAI,CAAC,KAAK,EAAE;QAC7B,OAAO;IACT;IACA,IAAI,MAAM,IAAI,CAAC,QAAQ,EAAE;QACvB,OAAO,MAAM,KAAK;IACpB;IACA,IAAI,MAAM,IAAI,KAAK,+KAAA,CAAA,OAAI,CAAC,KAAK,EAAE;QAC7B,OAAO,aAAa,OAAO,WAAW;IACxC;IACA,IAAI,MAAM,IAAI,KAAK,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE;QAC3B,OAAO,WAAW,OAAO,WAAW;IACtC;IACA,IAAI,MAAM,IAAI,KAAK,+KAAA,CAAA,OAAI,CAAC,GAAG,EAAE;QAC3B,IAAI,QAAQ,IAAI,IAAI,OAAO,QAAQ,IAAI,CAAC,MAAM,KAAK,CAAC,KAAK,YAAY;YACnE,MAAM,SAAS,eAAe,WAAW;YACzC,OAAO,QAAQ,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;QACnC;QACA,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,oBAAoB,EAAG,MAAM,KAAK,CAAE,CAAC,CAAC;IAC7E;IACA,MAAM,IAAI,MAAM;AAClB;AACA,SAAS,OAAO,IAAI,EAAE,OAAO;IAC3B,IAAI,CAAC,CAAC,gBAAgB,UAAU,GAAG;QACjC,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,oCAAoC,CAAC;IAC5E;IACA,UAAU,OAAO,MAAM,CAAC,CAAC,GAAG,sBAAsB;IAClD,MAAM,YAAY,QAAQ,SAAS,IAAI,IAAI,UAAU,MAAM;IAC3D,MAAM,UAAU,eAAe,WAAW;IAC1C,IAAI,YAAY,MAAM;QACpB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,mCAAmC,CAAC;IAC3E;IACA,IAAI,YAAY,OAAO;QACrB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,qBAAqB,CAAC;IAC7D;IACA,IAAI,CAAC,UAAU,IAAI,IAAI;QACrB,MAAM,IAAI,MAAM,GAAI,gLAAA,CAAA,kBAAe,CAAE,wCAAwC,CAAC;IAChF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8758, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/ipfs-repo/node_modules/cborg/esm/cborg.js"],"sourcesContent":["import { encode } from './lib/encode.js';\nimport { decode } from './lib/decode.js';\nimport {\n  Token,\n  Type\n} from './lib/token.js';\nexport {\n  decode,\n  encode,\n  Token,\n  Type\n};"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0],"debugId":null}}]
}